Milestone 2 already done:
- Server >> Game class created on Server side 
- Server >> Character class created on Server side 
- added new RPC called ```getCharacterList```
- renamed getCharacterList function
- added RPCImpl::rpcGetTraitList()
- added RPCImpl::getTraitNames()
- added Character::getTraitNames() to support RPCImpl::getTraitNames()
- updated Game::setSourceList() to call Game::addCharacter()
- added RPCImpl::rpcQueryTrait()
- added new RPC called ```getTraitList```


- Finished implementing RPC QueryTrait
- Implemented Client::queryTrait() function
- Added Client::getQueryTraitName() function
- Added Client::getQueryTraitValue() function (Customized user questions based on traitName selected)
- Added Client::validateUserInput() function
- Added Client::formatAnswer() function to standardize "queryTrait message" to make this RPC easier to process
- Added Client::trim() function to trim leading and trailing zeros
- Edited Client::Main to ensure code is running with expected output
- Edited RPCImpl::rpcQueryTrait() function to be responsible for parsing "queryTrait" message
- Moved query checking to new function RPCImpl::queryTraitResponse()
- Added customized server response in RPCImpl::customizedReply() function


- Server: Cleanup up console output for server to group RPCs into logical text blocks in display window
- Client: Modified displayCharacterList() in ClientMain to display characters and traits as a table
- Client: Created a 2D vector to hold the trait values for each character.


- Populated active list table on Client side
- Added Client::getTraitValuesFromServer() function
- Added RPCImpl::rpcGetTraitValues() function
- Adjusted data types of a couple of fields in Game class, Character class, and Client.h to facilitate RPC process, key value retrieval, and printing.

Milestone 2 TO DO:

- Eliminate Person -- consider no longer an RPC
  - (New design idea: Server does not need to know who have been eliminated. Client can just update its local copy by removing character names.)
  - Client >> Ask user who they want to eliminate, get input, update local copy
  - Client >> Based on user choice, eliminate entire row/rows of character name + traits from the active list 
  - Client >> Display the (shorter) table as needed

- RPC: Guess Name
  - Client >> Ask user who they want to guess
  - Client >> send guess to server 
  - Server >> process guess and send a response 
  - Server >> decide if player has made the correct guess 
  - Server >> update game state to "END" 
  

- Mutex application 
  - Server >> Create a map of <GameID, Game>, possibly in the Global context class 
  - Server >> Create two "GAME STATE": "IN-PROGRESS", "ENDED" (?)
  - Game class >> Possibly add a boolean "Game state" field in the Game class 
  - Server >> After a Game object is created, set "GAME STATE" to "IN-PROGRESS"
  - Server >> After a player has won, set "GAME STATE" to "ENDED"
  - Use mutex locker to ensure only one "GAME STATE" is updated at once

- Troubleshooting (as time allows)
  - clarify Client number discrepency between server and client (I suspect the socketID generated by the client and server is not identical)